--source include/galera_cluster.inc
--source include/have_debug.inc
--source include/have_debug_sync.inc
#
# Test 1: Execute update until lock_rec_unlock and execute conflicting
# update that will be killed.
#
--connection node_1
CREATE TABLE t1(a int not null primary key, b int, c int) engine=InnoDB;
INSERT INTO t1 VALUES (1,1,1),(2,2,1),(3,1,1),(4,2,2),(5,2,2),(6,1,1),(7,2,2),(8,1,1),(9,1,1);
#
# connection node_1b is for controlling debug sync points
# first set a sync point to lock_rec_unlock
#
--connect node_1b, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1b
SET GLOBAL debug_dbug = "d,sync.before_lock_rec_unlock";
#
# Now send UPDATE-statement that will use full table scan and update only
# rows with b = 2. Execution of this update will pause at lock_rec_unlock
#
--connect node_1d, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1d
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
--send UPDATE t1 SET c = 5 WHERE b = 2;
#
# Wait until we have reached lock_rec_unlock
#
--connection node_1b
SET SESSION DEBUG_SYNC='now WAIT_FOR sync.before_lock_rec_unlock_reached';
#
# Now we send UPDATE-statement that will update row with b = 1 so that
# it will wait the first statement.
#
--connect node_1c, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1c
begin;
--send UPDATE t1 SET c = 10 WHERE a = 3;
#
# Kill above update so that its row lock is released
#
--connection node_1b
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND INFO = 'UPDATE t1 SET c = 10 WHERE a = 3' LIMIT 1`

--disable_query_log
--eval KILL $k_thread
--enable_query_log
#
# Continue first update at lock_rec_unlock
#
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL signal.before_lock_rec_unlock";

--connection node_1d
--reap

--connection node_1c
--error 2013
--reap

--connection node_1b
SET DEBUG_SYNC = "RESET";

SELECT * FROM t1;
DROP TABLE t1;

--disconnect node_1b
--disconnect node_1c
--disconnect node_1d

#
# Test 2: Execute update until lock_rec_unlock and kill it
#
--connection node_1
CREATE TABLE t1(a int not null primary key, b int, c int) engine=InnoDB;
INSERT INTO t1 VALUES (1,1,1),(2,2,1),(3,1,1),(4,2,2),(5,2,2),(6,1,1),(7,2,2),(8,1,1),(9,1,1);
#
# connection node_1b is for controlling debug sync points
# first set a sync point to lock_rec_unlock
#
--connect node_1b, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1b
SET GLOBAL debug_dbug = "d,sync.before_lock_rec_unlock";
#
# Now send UPDATE-statement that will use full table scan and update only
# rows with b = 2. Execution of this update will pause at lock_rec_unlock
#
--connect node_1d, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1d
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
--send UPDATE t1 SET c = 5 WHERE b = 2;
#
# Wait until we have reached lock_rec_unlock
#
--connection node_1b
SET SESSION DEBUG_SYNC='now WAIT_FOR sync.before_lock_rec_unlock_reached';
#
# Kill above update
#
--connection node_1b
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND INFO = 'UPDATE t1 SET c = 5 WHERE b = 2' LIMIT 1`

--disable_query_log
--eval KILL $k_thread
--enable_query_log
#
# Continue first update at lock_rec_unlock
#
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL signal.before_lock_rec_unlock";

--connection node_1d
--error 2013
--reap

--connection node_1b
SET DEBUG_SYNC = "RESET";

--connection node_1
SELECT * FROM t1;
DROP TABLE t1;

--disconnect node_1b
--disconnect node_1d

#
# Test 3: Execute update until lock_rec_unlock and execute conflicting update
# kill both
#
--connection node_1
CREATE TABLE t1(a int not null primary key, b int, c int) engine=InnoDB;
INSERT INTO t1 VALUES (1,1,1),(2,2,1),(3,1,1),(4,2,2),(5,2,2),(6,1,1),(7,2,2),(8,1,1),(9,1,1);
#
# connection node_1b is for controlling debug sync points
# first set a sync point to lock_rec_unlock
#
--connect node_1b, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1b
SET GLOBAL debug_dbug = "d,sync.before_lock_rec_unlock";
#
# Now send UPDATE-statement that will use full table scan and update only
# rows with b = 2. Execution of this update will pause at lock_rec_unlock
#
--connect node_1d, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1d
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
--send UPDATE t1 SET c = 5 WHERE b = 2;
#
# Wait until we have reached lock_rec_unlock
#
--connection node_1b
SET SESSION DEBUG_SYNC='now WAIT_FOR sync.before_lock_rec_unlock_reached';
#
# Now we send UPDATE-statement that will update row with b = 1 so that
# it will wait the first statement.
#
--connect node_1c, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1c
begin;
--send UPDATE t1 SET c = 10 WHERE a = 3;
#
# Kill both, first first update then later one
#
--connection node_1b
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND INFO = 'UPDATE t1 SET c = 10 WHERE a = 3' LIMIT 1`

--disable_query_log
--eval KILL $k_thread
--enable_query_log

--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND INFO = 'UPDATE t1 SET c = 5 WHERE b = 2' LIMIT 1`

--disable_query_log
--eval KILL $k_thread
--enable_query_log
#
# Continue first update at lock_rec_unlock
#
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL signal.before_lock_rec_unlock";

--connection node_1c
--error 2013
--reap

--connection node_1d
--error 2013
--reap

--connection node_1b
SET DEBUG_SYNC = "RESET";

--connection node_1
SELECT * FROM t1;
DROP TABLE t1;

--disconnect node_1b
--disconnect node_1c
--disconnect node_1d


#
# Test 4: Execute update until lock_rec_unlock and execute conflicting update
# kill both, but change order of kill
#
--connection node_1
CREATE TABLE t1(a int not null primary key, b int, c int) engine=InnoDB;
INSERT INTO t1 VALUES (1,1,1),(2,2,1),(3,1,1),(4,2,2),(5,2,2),(6,1,1),(7,2,2),(8,1,1),(9,1,1);
#
# connection node_1b is for controlling debug sync points
# first set a sync point to lock_rec_unlock
#
--connect node_1b, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1b
SET GLOBAL debug_dbug = "d,sync.before_lock_rec_unlock";
#
# Now send UPDATE-statement that will use full table scan and update only
# rows with b = 2. Execution of this update will pause at lock_rec_unlock
#
--connect node_1d, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1d
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
--send UPDATE t1 SET c = 5 WHERE b = 2;
#
# Wait until we have reached lock_rec_unlock
#
--connection node_1b
SET SESSION DEBUG_SYNC='now WAIT_FOR sync.before_lock_rec_unlock_reached';
#
# Now we send UPDATE-statement that will update row with b = 1 so that
# it will wait the first statement.
#
--connect node_1c, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1c
begin;
--send UPDATE t1 SET c = 10 WHERE a = 3;
#
# Kill both, first later update then first
#
--connection node_1b
--let $k_thread = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND INFO = 'UPDATE t1 SET c = 5 WHERE b = 2' LIMIT 1`
--let $k_thread2 = `SELECT ID FROM INFORMATION_SCHEMA.PROCESSLIST WHERE USER = 'root' AND INFO = 'UPDATE t1 SET c = 10 WHERE a = 3' LIMIT 1`

--disable_query_log
--eval KILL $k_thread
--eval KILL $k_thread2
--enable_query_log
#
# Continue first update at lock_rec_unlock
#
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL signal.before_lock_rec_unlock";

--connection node_1c
--error 2013
--reap

--connection node_1d
--error 2013
--reap

--connection node_1b
SET DEBUG_SYNC = "RESET";

--connection node_1
SELECT * FROM t1;
DROP TABLE t1;

--disconnect node_1b
--disconnect node_1c
--disconnect node_1d
#
# Test 5: Execute update until lock_rec_unlock and execute TOI
#
--connection node_1
CREATE TABLE t1(a int not null primary key, b int, c int) engine=InnoDB;
INSERT INTO t1 VALUES (1,1,1),(2,2,1),(3,1,1),(4,2,2),(5,2,2),(6,1,1),(7,2,2),(8,1,1),(9,1,1);
#
# connection node_1b is for controlling debug sync points
# first set a sync point to lock_rec_unlock
#
--connect node_1b, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1b
SET GLOBAL debug_dbug = "d,sync.before_lock_rec_unlock";
#
# Now send UPDATE-statement that will use full table scan and update only
# rows with b = 2. Execution of this update will pause at lock_rec_unlock
#
--connect node_1d, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1d
SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
BEGIN;
--send UPDATE t1 SET c = 5 WHERE b = 2;
#
# Wait until we have reached lock_rec_unlock
#
--connection node_1b
SET SESSION DEBUG_SYNC='now WAIT_FOR sync.before_lock_rec_unlock_reached';
#
# Now we send TOI
#
--connect node_1c, 127.0.0.1, root, , test, $NODE_MYPORT_1
--connection node_1c
--send ALTER TABLE t1 ADD KEY b(b), ALGORITHM=INPLACE, LOCK=EXCLUSIVE;
#
# Continue first update at lock_rec_unlock
#
--connection node_1b
SET GLOBAL debug_dbug = "";
SET DEBUG_SYNC = "now SIGNAL signal.before_lock_rec_unlock";

--connection node_1d
--reap

--connection node_1b
SET DEBUG_SYNC = "RESET";

--connection node_1c
--reap
SHOW CREATE TABLE t1;

--connection node_1
SELECT * FROM t1;
DROP TABLE t1;

--disconnect node_1b
